// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ortools/constraint_solver/routing_parameters.proto

package com.google.ortools.constraintsolver;

public interface RoutingSearchParametersOrBuilder extends
    // @@protoc_insertion_point(interface_extends:operations_research.RoutingSearchParameters)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * First solution strategies, used as starting point of local search.
   * </pre>
   *
   * <code>.operations_research.FirstSolutionStrategy.Value first_solution_strategy = 1;</code>
   * @return The enum numeric value on the wire for firstSolutionStrategy.
   */
  int getFirstSolutionStrategyValue();
  /**
   * <pre>
   * First solution strategies, used as starting point of local search.
   * </pre>
   *
   * <code>.operations_research.FirstSolutionStrategy.Value first_solution_strategy = 1;</code>
   * @return The firstSolutionStrategy.
   */
  com.google.ortools.constraintsolver.FirstSolutionStrategy.Value getFirstSolutionStrategy();

  /**
   * <pre>
   * --- Advanced first solutions strategy settings ---
   * Don't touch these unless you know what you are doing.
   * Use filtered version of first solution strategy if available.
   * </pre>
   *
   * <code>bool use_unfiltered_first_solution_strategy = 2;</code>
   * @return The useUnfilteredFirstSolutionStrategy.
   */
  boolean getUseUnfilteredFirstSolutionStrategy();

  /**
   * <pre>
   * Parameters specific to the Savings first solution heuristic.
   * Ratio (in ]0, 1]) of neighbors to consider for each node when constructing
   * the savings. If unspecified, its value is considered to be 1.0.
   * </pre>
   *
   * <code>double savings_neighbors_ratio = 14;</code>
   * @return The savingsNeighborsRatio.
   */
  double getSavingsNeighborsRatio();

  /**
   * <pre>
   * The number of neighbors considered for each node in the Savings heuristic
   * is chosen so that the space used to store the savings doesn't exceed
   * savings_max_memory_usage_bytes, which must be in ]0, 1e10].
   * NOTE: If both savings_neighbors_ratio and savings_max_memory_usage_bytes
   * are specified, the number of neighbors considered for each node will be the
   * minimum of the two numbers determined by these parameters.
   * </pre>
   *
   * <code>double savings_max_memory_usage_bytes = 23;</code>
   * @return The savingsMaxMemoryUsageBytes.
   */
  double getSavingsMaxMemoryUsageBytes();

  /**
   * <pre>
   * Add savings related to reverse arcs when finding the nearest neighbors
   * of the nodes.
   * </pre>
   *
   * <code>bool savings_add_reverse_arcs = 15;</code>
   * @return The savingsAddReverseArcs.
   */
  boolean getSavingsAddReverseArcs();

  /**
   * <pre>
   * Coefficient of the cost of the arc for which the saving value is being
   * computed:
   * Saving(a--&gt;b) = Cost(a--&gt;end) + Cost(start--&gt;b)
   *                 - savings_arc_coefficient * Cost(a--&gt;b)
   * This parameter must be greater than 0, and its default value is 1.
   * </pre>
   *
   * <code>double savings_arc_coefficient = 18;</code>
   * @return The savingsArcCoefficient.
   */
  double getSavingsArcCoefficient();

  /**
   * <pre>
   * When true, the routes are built in parallel, sequentially otherwise.
   * </pre>
   *
   * <code>bool savings_parallel_routes = 19;</code>
   * @return The savingsParallelRoutes.
   */
  boolean getSavingsParallelRoutes();

  /**
   * <pre>
   * Ratio (between 0 and 1) of available vehicles in the model on which
   * farthest nodes of the model are inserted as seeds in the
   * GlobalCheapestInsertion first solution heuristic.
   * </pre>
   *
   * <code>double cheapest_insertion_farthest_seeds_ratio = 16;</code>
   * @return The cheapestInsertionFarthestSeedsRatio.
   */
  double getCheapestInsertionFarthestSeedsRatio();

  /**
   * <pre>
   * Ratio (in ]0, 1]) of neighbors to consider for each node when creating
   * new insertions in the parallel/sequential cheapest insertion heuristic.
   * If not overridden, its default value is 1, meaning all neighbors will be
   * considered.
   * Neighbors ratio for the first solution heuristic.
   * </pre>
   *
   * <code>double cheapest_insertion_first_solution_neighbors_ratio = 21;</code>
   * @return The cheapestInsertionFirstSolutionNeighborsRatio.
   */
  double getCheapestInsertionFirstSolutionNeighborsRatio();

  /**
   * <pre>
   * Neighbors ratio for the heuristic when used in a local search operator (see
   * local_search_operators.use_global_cheapest_insertion_path_lns and
   * local_search_operators.use_global_cheapest_insertion_chain_lns below).
   * </pre>
   *
   * <code>double cheapest_insertion_ls_operator_neighbors_ratio = 31;</code>
   * @return The cheapestInsertionLsOperatorNeighborsRatio.
   */
  double getCheapestInsertionLsOperatorNeighborsRatio();

  /**
   * <pre>
   * If true use minimum matching instead of minimal matching in the
   * Christofides algorithm.
   * </pre>
   *
   * <code>bool christofides_use_minimum_matching = 30;</code>
   * @return The christofidesUseMinimumMatching.
   */
  boolean getChristofidesUseMinimumMatching();

  /**
   * <code>.operations_research.RoutingSearchParameters.LocalSearchNeighborhoodOperators local_search_operators = 3;</code>
   * @return Whether the localSearchOperators field is set.
   */
  boolean hasLocalSearchOperators();
  /**
   * <code>.operations_research.RoutingSearchParameters.LocalSearchNeighborhoodOperators local_search_operators = 3;</code>
   * @return The localSearchOperators.
   */
  com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperators getLocalSearchOperators();
  /**
   * <code>.operations_research.RoutingSearchParameters.LocalSearchNeighborhoodOperators local_search_operators = 3;</code>
   */
  com.google.ortools.constraintsolver.RoutingSearchParameters.LocalSearchNeighborhoodOperatorsOrBuilder getLocalSearchOperatorsOrBuilder();

  /**
   * <pre>
   * Number of expensive arcs to consider cutting in the RelocateExpensiveChain
   * neighborhood operator (see
   * LocalSearchNeighborhoodOperators.use_relocate_expensive_chain()).
   * This parameter must be greater than 2.
   * NOTE(user): The number of neighbors generated by the operator for
   * relocate_expensive_chain_num_arcs_to_consider = K is around
   * K*(K-1)/2 * number_of_routes * number_of_nodes.
   * </pre>
   *
   * <code>int32 relocate_expensive_chain_num_arcs_to_consider = 20;</code>
   * @return The relocateExpensiveChainNumArcsToConsider.
   */
  int getRelocateExpensiveChainNumArcsToConsider();

  /**
   * <pre>
   * Number of expensive arcs to consider cutting in the
   * FilteredHeuristicExpensiveChainLNSOperator operator.
   * </pre>
   *
   * <code>int32 heuristic_expensive_chain_lns_num_arcs_to_consider = 32;</code>
   * @return The heuristicExpensiveChainLnsNumArcsToConsider.
   */
  int getHeuristicExpensiveChainLnsNumArcsToConsider();

  /**
   * <pre>
   * Local search metaheuristics used to guide the search.
   * </pre>
   *
   * <code>.operations_research.LocalSearchMetaheuristic.Value local_search_metaheuristic = 4;</code>
   * @return The enum numeric value on the wire for localSearchMetaheuristic.
   */
  int getLocalSearchMetaheuristicValue();
  /**
   * <pre>
   * Local search metaheuristics used to guide the search.
   * </pre>
   *
   * <code>.operations_research.LocalSearchMetaheuristic.Value local_search_metaheuristic = 4;</code>
   * @return The localSearchMetaheuristic.
   */
  com.google.ortools.constraintsolver.LocalSearchMetaheuristic.Value getLocalSearchMetaheuristic();

  /**
   * <pre>
   * These are advanced settings which should not be modified unless you know
   * what you are doing.
   * Lambda coefficient used to penalize arc costs when GUIDED_LOCAL_SEARCH is
   * used. Must be positive.
   * </pre>
   *
   * <code>double guided_local_search_lambda_coefficient = 5;</code>
   * @return The guidedLocalSearchLambdaCoefficient.
   */
  double getGuidedLocalSearchLambdaCoefficient();

  /**
   * <pre>
   * --- Search control ---
   * If true, the solver should use depth-first search rather than local search
   * to solve the problem.
   * </pre>
   *
   * <code>bool use_depth_first_search = 6;</code>
   * @return The useDepthFirstSearch.
   */
  boolean getUseDepthFirstSearch();

  /**
   * <pre>
   * If true, use the CP solver to find a solution. Either local or depth-first
   * search will be used depending on the value of use_depth_first_search. Will
   * be run before the CP-SAT solver (cf. use_cp_sat).
   * </pre>
   *
   * <code>.operations_research.OptionalBoolean use_cp = 28;</code>
   * @return The enum numeric value on the wire for useCp.
   */
  int getUseCpValue();
  /**
   * <pre>
   * If true, use the CP solver to find a solution. Either local or depth-first
   * search will be used depending on the value of use_depth_first_search. Will
   * be run before the CP-SAT solver (cf. use_cp_sat).
   * </pre>
   *
   * <code>.operations_research.OptionalBoolean use_cp = 28;</code>
   * @return The useCp.
   */
  com.google.ortools.util.OptionalBoolean getUseCp();

  /**
   * <pre>
   * If true, use the CP-SAT solver to find a solution. If use_cp is also true,
   * the CP-SAT solver will be run after the CP solver if there is time
   * remaining and will use the CP solution as a hint for the CP-SAT search.
   * As of 5/2019, only TSP models can be solved.
   * </pre>
   *
   * <code>.operations_research.OptionalBoolean use_cp_sat = 27;</code>
   * @return The enum numeric value on the wire for useCpSat.
   */
  int getUseCpSatValue();
  /**
   * <pre>
   * If true, use the CP-SAT solver to find a solution. If use_cp is also true,
   * the CP-SAT solver will be run after the CP solver if there is time
   * remaining and will use the CP solution as a hint for the CP-SAT search.
   * As of 5/2019, only TSP models can be solved.
   * </pre>
   *
   * <code>.operations_research.OptionalBoolean use_cp_sat = 27;</code>
   * @return The useCpSat.
   */
  com.google.ortools.util.OptionalBoolean getUseCpSat();

  /**
   * <code>.operations_research.RoutingSearchParameters.SchedulingSolver continuous_scheduling_solver = 33;</code>
   * @return The enum numeric value on the wire for continuousSchedulingSolver.
   */
  int getContinuousSchedulingSolverValue();
  /**
   * <code>.operations_research.RoutingSearchParameters.SchedulingSolver continuous_scheduling_solver = 33;</code>
   * @return The continuousSchedulingSolver.
   */
  com.google.ortools.constraintsolver.RoutingSearchParameters.SchedulingSolver getContinuousSchedulingSolver();

  /**
   * <code>.operations_research.RoutingSearchParameters.SchedulingSolver mixed_integer_scheduling_solver = 34;</code>
   * @return The enum numeric value on the wire for mixedIntegerSchedulingSolver.
   */
  int getMixedIntegerSchedulingSolverValue();
  /**
   * <code>.operations_research.RoutingSearchParameters.SchedulingSolver mixed_integer_scheduling_solver = 34;</code>
   * @return The mixedIntegerSchedulingSolver.
   */
  com.google.ortools.constraintsolver.RoutingSearchParameters.SchedulingSolver getMixedIntegerSchedulingSolver();

  /**
   * <pre>
   * Minimum step by which the solution must be improved in local search. 0
   * means "unspecified". If this value is fractional, it will get rounded to
   * the nearest integer.
   * </pre>
   *
   * <code>double optimization_step = 7;</code>
   * @return The optimizationStep.
   */
  double getOptimizationStep();

  /**
   * <pre>
   * Number of solutions to collect during the search. Corresponds to the best
   * solutions found during the search. 0 means "unspecified".
   * </pre>
   *
   * <code>int32 number_of_solutions_to_collect = 17;</code>
   * @return The numberOfSolutionsToCollect.
   */
  int getNumberOfSolutionsToCollect();

  /**
   * <pre>
   * -- Search limits --
   * Limit to the number of solutions generated during the search. 0 means
   * "unspecified".
   * </pre>
   *
   * <code>int64 solution_limit = 8;</code>
   * @return The solutionLimit.
   */
  long getSolutionLimit();

  /**
   * <pre>
   * Limit to the time spent in the search.
   * </pre>
   *
   * <code>.google.protobuf.Duration time_limit = 9;</code>
   * @return Whether the timeLimit field is set.
   */
  boolean hasTimeLimit();
  /**
   * <pre>
   * Limit to the time spent in the search.
   * </pre>
   *
   * <code>.google.protobuf.Duration time_limit = 9;</code>
   * @return The timeLimit.
   */
  com.google.protobuf.Duration getTimeLimit();
  /**
   * <pre>
   * Limit to the time spent in the search.
   * </pre>
   *
   * <code>.google.protobuf.Duration time_limit = 9;</code>
   */
  com.google.protobuf.DurationOrBuilder getTimeLimitOrBuilder();

  /**
   * <pre>
   * Limit to the time spent in the completion search for each local search
   * neighbor.
   * </pre>
   *
   * <code>.google.protobuf.Duration lns_time_limit = 10;</code>
   * @return Whether the lnsTimeLimit field is set.
   */
  boolean hasLnsTimeLimit();
  /**
   * <pre>
   * Limit to the time spent in the completion search for each local search
   * neighbor.
   * </pre>
   *
   * <code>.google.protobuf.Duration lns_time_limit = 10;</code>
   * @return The lnsTimeLimit.
   */
  com.google.protobuf.Duration getLnsTimeLimit();
  /**
   * <pre>
   * Limit to the time spent in the completion search for each local search
   * neighbor.
   * </pre>
   *
   * <code>.google.protobuf.Duration lns_time_limit = 10;</code>
   */
  com.google.protobuf.DurationOrBuilder getLnsTimeLimitOrBuilder();

  /**
   * <pre>
   * --- Propagation control ---
   * These are advanced settings which should not be modified unless you know
   * what you are doing.
   * Use constraints with full propagation in routing model (instead of 'light'
   * propagation only). Full propagation is only necessary when using
   * depth-first search or for models which require strong propagation to
   * finalize the value of secondary variables.
   * Changing this setting to true will slow down the search in most cases and
   * increase memory consumption in all cases.
   * </pre>
   *
   * <code>bool use_full_propagation = 11;</code>
   * @return The useFullPropagation.
   */
  boolean getUseFullPropagation();

  /**
   * <pre>
   * --- Miscellaneous ---
   * Some of these are advanced settings which should not be modified unless you
   * know what you are doing.
   * Activates search logging. For each solution found during the search, the
   * following will be displayed: its objective value, the maximum objective
   * value since the beginning of the search, the elapsed time since the
   * beginning of the search, the number of branches explored in the search
   * tree, the number of failures in the search tree, the depth of the search
   * tree, the number of local search neighbors explored, the number of local
   * search neighbors filtered by local search filters, the number of local
   * search neighbors accepted, the total memory used and the percentage of the
   * search done.
   * </pre>
   *
   * <code>bool log_search = 13;</code>
   * @return The logSearch.
   */
  boolean getLogSearch();

  /**
   * <pre>
   * In logs, cost values will be scaled and offset by the given values in the
   * following way: log_cost_scaling_factor * (cost + log_cost_offset)
   * </pre>
   *
   * <code>double log_cost_scaling_factor = 22;</code>
   * @return The logCostScalingFactor.
   */
  double getLogCostScalingFactor();

  /**
   * <code>double log_cost_offset = 29;</code>
   * @return The logCostOffset.
   */
  double getLogCostOffset();
}

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ortools/sat/cp_model.proto

package com.google.ortools.sat;

public interface CpSolverResponseOrBuilder extends
    // @@protoc_insertion_point(interface_extends:operations_research.sat.CpSolverResponse)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * The status of the solve.
   * </pre>
   *
   * <code>.operations_research.sat.CpSolverStatus status = 1;</code>
   * @return The enum numeric value on the wire for status.
   */
  int getStatusValue();
  /**
   * <pre>
   * The status of the solve.
   * </pre>
   *
   * <code>.operations_research.sat.CpSolverStatus status = 1;</code>
   * @return The status.
   */
  com.google.ortools.sat.CpSolverStatus getStatus();

  /**
   * <pre>
   * A feasible solution to the given problem. Depending on the returned status
   * it may be optimal or just feasible. This is in one-to-one correspondence
   * with a CpModelProto::variables repeated field and list the values of all
   * the variables.
   * </pre>
   *
   * <code>repeated int64 solution = 2;</code>
   * @return A list containing the solution.
   */
  java.util.List<java.lang.Long> getSolutionList();
  /**
   * <pre>
   * A feasible solution to the given problem. Depending on the returned status
   * it may be optimal or just feasible. This is in one-to-one correspondence
   * with a CpModelProto::variables repeated field and list the values of all
   * the variables.
   * </pre>
   *
   * <code>repeated int64 solution = 2;</code>
   * @return The count of solution.
   */
  int getSolutionCount();
  /**
   * <pre>
   * A feasible solution to the given problem. Depending on the returned status
   * it may be optimal or just feasible. This is in one-to-one correspondence
   * with a CpModelProto::variables repeated field and list the values of all
   * the variables.
   * </pre>
   *
   * <code>repeated int64 solution = 2;</code>
   * @param index The index of the element to return.
   * @return The solution at the given index.
   */
  long getSolution(int index);

  /**
   * <pre>
   * Only make sense for an optimization problem. The objective value of the
   * returned solution if it is non-empty. If there is no solution, then for a
   * minimization problem, this will be an upper-bound of the objective of any
   * feasible solution, and a lower-bound for a maximization problem.
   * </pre>
   *
   * <code>double objective_value = 3;</code>
   * @return The objectiveValue.
   */
  double getObjectiveValue();

  /**
   * <pre>
   * Only make sense for an optimization problem. A proven lower-bound on the
   * objective for a minimization problem, or a proven upper-bound for a
   * maximization problem.
   * </pre>
   *
   * <code>double best_objective_bound = 4;</code>
   * @return The bestObjectiveBound.
   */
  double getBestObjectiveBound();

  /**
   * <pre>
   * Advanced usage.
   * If the problem has some variables that are not fixed at the end of the
   * search (because of a particular search strategy in the CpModelProto) then
   * this will be used instead of filling the solution above. The two fields
   * will then contains the lower and upper bounds of each variable as they were
   * when the best "solution" was found.
   * </pre>
   *
   * <code>repeated int64 solution_lower_bounds = 18;</code>
   * @return A list containing the solutionLowerBounds.
   */
  java.util.List<java.lang.Long> getSolutionLowerBoundsList();
  /**
   * <pre>
   * Advanced usage.
   * If the problem has some variables that are not fixed at the end of the
   * search (because of a particular search strategy in the CpModelProto) then
   * this will be used instead of filling the solution above. The two fields
   * will then contains the lower and upper bounds of each variable as they were
   * when the best "solution" was found.
   * </pre>
   *
   * <code>repeated int64 solution_lower_bounds = 18;</code>
   * @return The count of solutionLowerBounds.
   */
  int getSolutionLowerBoundsCount();
  /**
   * <pre>
   * Advanced usage.
   * If the problem has some variables that are not fixed at the end of the
   * search (because of a particular search strategy in the CpModelProto) then
   * this will be used instead of filling the solution above. The two fields
   * will then contains the lower and upper bounds of each variable as they were
   * when the best "solution" was found.
   * </pre>
   *
   * <code>repeated int64 solution_lower_bounds = 18;</code>
   * @param index The index of the element to return.
   * @return The solutionLowerBounds at the given index.
   */
  long getSolutionLowerBounds(int index);

  /**
   * <code>repeated int64 solution_upper_bounds = 19;</code>
   * @return A list containing the solutionUpperBounds.
   */
  java.util.List<java.lang.Long> getSolutionUpperBoundsList();
  /**
   * <code>repeated int64 solution_upper_bounds = 19;</code>
   * @return The count of solutionUpperBounds.
   */
  int getSolutionUpperBoundsCount();
  /**
   * <code>repeated int64 solution_upper_bounds = 19;</code>
   * @param index The index of the element to return.
   * @return The solutionUpperBounds at the given index.
   */
  long getSolutionUpperBounds(int index);

  /**
   * <pre>
   * Advanced usage.
   * If the option fill_tightened_domains_in_response is set, then this field
   * will be a copy of the CpModelProto.variables where each domain has been
   * reduced using the information the solver was able to derive. Note that this
   * is only filled with the info derived during a normal search and we do not
   * have any dedicated algorithm to improve it.
   * If the problem is a feasibility problem, then these bounds will be valid
   * for any feasible solution. If the problem is an optimization problem, then
   * these bounds will only be valid for any OPTIMAL solutions, it can exclude
   * sub-optimal feasible ones.
   * </pre>
   *
   * <code>repeated .operations_research.sat.IntegerVariableProto tightened_variables = 21;</code>
   */
  java.util.List<com.google.ortools.sat.IntegerVariableProto> 
      getTightenedVariablesList();
  /**
   * <pre>
   * Advanced usage.
   * If the option fill_tightened_domains_in_response is set, then this field
   * will be a copy of the CpModelProto.variables where each domain has been
   * reduced using the information the solver was able to derive. Note that this
   * is only filled with the info derived during a normal search and we do not
   * have any dedicated algorithm to improve it.
   * If the problem is a feasibility problem, then these bounds will be valid
   * for any feasible solution. If the problem is an optimization problem, then
   * these bounds will only be valid for any OPTIMAL solutions, it can exclude
   * sub-optimal feasible ones.
   * </pre>
   *
   * <code>repeated .operations_research.sat.IntegerVariableProto tightened_variables = 21;</code>
   */
  com.google.ortools.sat.IntegerVariableProto getTightenedVariables(int index);
  /**
   * <pre>
   * Advanced usage.
   * If the option fill_tightened_domains_in_response is set, then this field
   * will be a copy of the CpModelProto.variables where each domain has been
   * reduced using the information the solver was able to derive. Note that this
   * is only filled with the info derived during a normal search and we do not
   * have any dedicated algorithm to improve it.
   * If the problem is a feasibility problem, then these bounds will be valid
   * for any feasible solution. If the problem is an optimization problem, then
   * these bounds will only be valid for any OPTIMAL solutions, it can exclude
   * sub-optimal feasible ones.
   * </pre>
   *
   * <code>repeated .operations_research.sat.IntegerVariableProto tightened_variables = 21;</code>
   */
  int getTightenedVariablesCount();
  /**
   * <pre>
   * Advanced usage.
   * If the option fill_tightened_domains_in_response is set, then this field
   * will be a copy of the CpModelProto.variables where each domain has been
   * reduced using the information the solver was able to derive. Note that this
   * is only filled with the info derived during a normal search and we do not
   * have any dedicated algorithm to improve it.
   * If the problem is a feasibility problem, then these bounds will be valid
   * for any feasible solution. If the problem is an optimization problem, then
   * these bounds will only be valid for any OPTIMAL solutions, it can exclude
   * sub-optimal feasible ones.
   * </pre>
   *
   * <code>repeated .operations_research.sat.IntegerVariableProto tightened_variables = 21;</code>
   */
  java.util.List<? extends com.google.ortools.sat.IntegerVariableProtoOrBuilder> 
      getTightenedVariablesOrBuilderList();
  /**
   * <pre>
   * Advanced usage.
   * If the option fill_tightened_domains_in_response is set, then this field
   * will be a copy of the CpModelProto.variables where each domain has been
   * reduced using the information the solver was able to derive. Note that this
   * is only filled with the info derived during a normal search and we do not
   * have any dedicated algorithm to improve it.
   * If the problem is a feasibility problem, then these bounds will be valid
   * for any feasible solution. If the problem is an optimization problem, then
   * these bounds will only be valid for any OPTIMAL solutions, it can exclude
   * sub-optimal feasible ones.
   * </pre>
   *
   * <code>repeated .operations_research.sat.IntegerVariableProto tightened_variables = 21;</code>
   */
  com.google.ortools.sat.IntegerVariableProtoOrBuilder getTightenedVariablesOrBuilder(
      int index);

  /**
   * <pre>
   * A subset of the model "assumptions" field. This will only be filled if the
   * status is INFEASIBLE. This subset of assumption will be enough to still get
   * an infeasible problem.
   * This is related to what is called the irreducible inconsistent subsystem or
   * IIS. Except one is only concerned by the provided assumptions. There is
   * also no guarantee that we return an irreducible (aka minimal subset).
   * However, this is based on SAT explanation and there is a good chance it is
   * not too large.
   * If you really want a minimal subset, a possible way to get one is by
   * changing your model to minimize the number of assumptions at false, but
   * this is likely an harder problem to solve.
   * TODO(user): Allows for returning multiple core at once.
   * </pre>
   *
   * <code>repeated int32 sufficient_assumptions_for_infeasibility = 23;</code>
   * @return A list containing the sufficientAssumptionsForInfeasibility.
   */
  java.util.List<java.lang.Integer> getSufficientAssumptionsForInfeasibilityList();
  /**
   * <pre>
   * A subset of the model "assumptions" field. This will only be filled if the
   * status is INFEASIBLE. This subset of assumption will be enough to still get
   * an infeasible problem.
   * This is related to what is called the irreducible inconsistent subsystem or
   * IIS. Except one is only concerned by the provided assumptions. There is
   * also no guarantee that we return an irreducible (aka minimal subset).
   * However, this is based on SAT explanation and there is a good chance it is
   * not too large.
   * If you really want a minimal subset, a possible way to get one is by
   * changing your model to minimize the number of assumptions at false, but
   * this is likely an harder problem to solve.
   * TODO(user): Allows for returning multiple core at once.
   * </pre>
   *
   * <code>repeated int32 sufficient_assumptions_for_infeasibility = 23;</code>
   * @return The count of sufficientAssumptionsForInfeasibility.
   */
  int getSufficientAssumptionsForInfeasibilityCount();
  /**
   * <pre>
   * A subset of the model "assumptions" field. This will only be filled if the
   * status is INFEASIBLE. This subset of assumption will be enough to still get
   * an infeasible problem.
   * This is related to what is called the irreducible inconsistent subsystem or
   * IIS. Except one is only concerned by the provided assumptions. There is
   * also no guarantee that we return an irreducible (aka minimal subset).
   * However, this is based on SAT explanation and there is a good chance it is
   * not too large.
   * If you really want a minimal subset, a possible way to get one is by
   * changing your model to minimize the number of assumptions at false, but
   * this is likely an harder problem to solve.
   * TODO(user): Allows for returning multiple core at once.
   * </pre>
   *
   * <code>repeated int32 sufficient_assumptions_for_infeasibility = 23;</code>
   * @param index The index of the element to return.
   * @return The sufficientAssumptionsForInfeasibility at the given index.
   */
  int getSufficientAssumptionsForInfeasibility(int index);

  /**
   * <pre>
   * This will be true iff the solver was asked to find all solutions to a
   * satisfiability problem (or all optimal solutions to an optimization
   * problem), and it was successful in doing so.
   * TODO(user): Remove as we also use the OPTIMAL vs FEASIBLE status for that.
   * </pre>
   *
   * <code>bool all_solutions_were_found = 5;</code>
   * @return The allSolutionsWereFound.
   */
  boolean getAllSolutionsWereFound();

  /**
   * <pre>
   * Some statistics about the solve.
   * </pre>
   *
   * <code>int64 num_booleans = 10;</code>
   * @return The numBooleans.
   */
  long getNumBooleans();

  /**
   * <code>int64 num_conflicts = 11;</code>
   * @return The numConflicts.
   */
  long getNumConflicts();

  /**
   * <code>int64 num_branches = 12;</code>
   * @return The numBranches.
   */
  long getNumBranches();

  /**
   * <code>int64 num_binary_propagations = 13;</code>
   * @return The numBinaryPropagations.
   */
  long getNumBinaryPropagations();

  /**
   * <code>int64 num_integer_propagations = 14;</code>
   * @return The numIntegerPropagations.
   */
  long getNumIntegerPropagations();

  /**
   * <code>double wall_time = 15;</code>
   * @return The wallTime.
   */
  double getWallTime();

  /**
   * <code>double user_time = 16;</code>
   * @return The userTime.
   */
  double getUserTime();

  /**
   * <code>double deterministic_time = 17;</code>
   * @return The deterministicTime.
   */
  double getDeterministicTime();

  /**
   * <code>double primal_integral = 22;</code>
   * @return The primalIntegral.
   */
  double getPrimalIntegral();

  /**
   * <pre>
   * Additional information about how the solution was found.
   * </pre>
   *
   * <code>string solution_info = 20;</code>
   * @return The solutionInfo.
   */
  java.lang.String getSolutionInfo();
  /**
   * <pre>
   * Additional information about how the solution was found.
   * </pre>
   *
   * <code>string solution_info = 20;</code>
   * @return The bytes for solutionInfo.
   */
  com.google.protobuf.ByteString
      getSolutionInfoBytes();
}

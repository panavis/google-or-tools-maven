// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ortools/sat/cp_model.proto

package com.google.ortools.sat;

public interface CpObjectiveProtoOrBuilder extends
    // @@protoc_insertion_point(interface_extends:operations_research.sat.CpObjectiveProto)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * The linear terms of the objective to minimize.
   * For a maximization problem, one can negate all coefficients in the
   * objective and set a scaling_factor to -1.
   * </pre>
   *
   * <code>repeated int32 vars = 1;</code>
   * @return A list containing the vars.
   */
  java.util.List<java.lang.Integer> getVarsList();
  /**
   * <pre>
   * The linear terms of the objective to minimize.
   * For a maximization problem, one can negate all coefficients in the
   * objective and set a scaling_factor to -1.
   * </pre>
   *
   * <code>repeated int32 vars = 1;</code>
   * @return The count of vars.
   */
  int getVarsCount();
  /**
   * <pre>
   * The linear terms of the objective to minimize.
   * For a maximization problem, one can negate all coefficients in the
   * objective and set a scaling_factor to -1.
   * </pre>
   *
   * <code>repeated int32 vars = 1;</code>
   * @param index The index of the element to return.
   * @return The vars at the given index.
   */
  int getVars(int index);

  /**
   * <code>repeated int64 coeffs = 4;</code>
   * @return A list containing the coeffs.
   */
  java.util.List<java.lang.Long> getCoeffsList();
  /**
   * <code>repeated int64 coeffs = 4;</code>
   * @return The count of coeffs.
   */
  int getCoeffsCount();
  /**
   * <code>repeated int64 coeffs = 4;</code>
   * @param index The index of the element to return.
   * @return The coeffs at the given index.
   */
  long getCoeffs(int index);

  /**
   * <pre>
   * The displayed objective is always:
   *   scaling_factor * (sum(coefficients[i] * objective_vars[i]) + offset).
   * This is needed to have a consistent objective after presolve or when
   * scaling a double problem to express it with integers.
   * Note that if scaling_factor is zero, then it is assumed to be 1, so that by
   * default these fields have no effect.
   * </pre>
   *
   * <code>double offset = 2;</code>
   * @return The offset.
   */
  double getOffset();

  /**
   * <code>double scaling_factor = 3;</code>
   * @return The scalingFactor.
   */
  double getScalingFactor();

  /**
   * <pre>
   * If non-empty, only look for an objective value in the given domain.
   * Note that this does not depend on the offset or scaling factor, it is a
   * domain on the sum of the objective terms only.
   * </pre>
   *
   * <code>repeated int64 domain = 5;</code>
   * @return A list containing the domain.
   */
  java.util.List<java.lang.Long> getDomainList();
  /**
   * <pre>
   * If non-empty, only look for an objective value in the given domain.
   * Note that this does not depend on the offset or scaling factor, it is a
   * domain on the sum of the objective terms only.
   * </pre>
   *
   * <code>repeated int64 domain = 5;</code>
   * @return The count of domain.
   */
  int getDomainCount();
  /**
   * <pre>
   * If non-empty, only look for an objective value in the given domain.
   * Note that this does not depend on the offset or scaling factor, it is a
   * domain on the sum of the objective terms only.
   * </pre>
   *
   * <code>repeated int64 domain = 5;</code>
   * @param index The index of the element to return.
   * @return The domain at the given index.
   */
  long getDomain(int index);
}

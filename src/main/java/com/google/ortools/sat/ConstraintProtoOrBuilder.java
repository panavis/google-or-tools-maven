// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ortools/sat/cp_model.proto

package com.google.ortools.sat;

public interface ConstraintProtoOrBuilder extends
    // @@protoc_insertion_point(interface_extends:operations_research.sat.ConstraintProto)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * For debug/logging only. Can be empty.
   * </pre>
   *
   * <code>string name = 1;</code>
   * @return The name.
   */
  java.lang.String getName();
  /**
   * <pre>
   * For debug/logging only. Can be empty.
   * </pre>
   *
   * <code>string name = 1;</code>
   * @return The bytes for name.
   */
  com.google.protobuf.ByteString
      getNameBytes();

  /**
   * <pre>
   * The constraint will be enforced iff all literals listed here are true. If
   * this is empty, then the constraint will always be enforced. An enforced
   * constraint must be satisfied, and an un-enforced one will simply be
   * ignored.
   * This is also called half-reification. To have an equivalence between a
   * literal and a constraint (full reification), one must add both a constraint
   * (controlled by a literal l) and its negation (controlled by the negation of
   * l).
   * Important: as of September 2018, only a few constraint support enforcement:
   * - bool_or, bool_and, linear: fully supported.
   * - interval: only support a single enforcement literal.
   * - other: no support (but can be added on a per-demand basis).
   * </pre>
   *
   * <code>repeated int32 enforcement_literal = 2;</code>
   * @return A list containing the enforcementLiteral.
   */
  java.util.List<java.lang.Integer> getEnforcementLiteralList();
  /**
   * <pre>
   * The constraint will be enforced iff all literals listed here are true. If
   * this is empty, then the constraint will always be enforced. An enforced
   * constraint must be satisfied, and an un-enforced one will simply be
   * ignored.
   * This is also called half-reification. To have an equivalence between a
   * literal and a constraint (full reification), one must add both a constraint
   * (controlled by a literal l) and its negation (controlled by the negation of
   * l).
   * Important: as of September 2018, only a few constraint support enforcement:
   * - bool_or, bool_and, linear: fully supported.
   * - interval: only support a single enforcement literal.
   * - other: no support (but can be added on a per-demand basis).
   * </pre>
   *
   * <code>repeated int32 enforcement_literal = 2;</code>
   * @return The count of enforcementLiteral.
   */
  int getEnforcementLiteralCount();
  /**
   * <pre>
   * The constraint will be enforced iff all literals listed here are true. If
   * this is empty, then the constraint will always be enforced. An enforced
   * constraint must be satisfied, and an un-enforced one will simply be
   * ignored.
   * This is also called half-reification. To have an equivalence between a
   * literal and a constraint (full reification), one must add both a constraint
   * (controlled by a literal l) and its negation (controlled by the negation of
   * l).
   * Important: as of September 2018, only a few constraint support enforcement:
   * - bool_or, bool_and, linear: fully supported.
   * - interval: only support a single enforcement literal.
   * - other: no support (but can be added on a per-demand basis).
   * </pre>
   *
   * <code>repeated int32 enforcement_literal = 2;</code>
   * @param index The index of the element to return.
   * @return The enforcementLiteral at the given index.
   */
  int getEnforcementLiteral(int index);

  /**
   * <pre>
   * The bool_or constraint forces at least one literal to be true.
   * </pre>
   *
   * <code>.operations_research.sat.BoolArgumentProto bool_or = 3;</code>
   * @return Whether the boolOr field is set.
   */
  boolean hasBoolOr();
  /**
   * <pre>
   * The bool_or constraint forces at least one literal to be true.
   * </pre>
   *
   * <code>.operations_research.sat.BoolArgumentProto bool_or = 3;</code>
   * @return The boolOr.
   */
  com.google.ortools.sat.BoolArgumentProto getBoolOr();
  /**
   * <pre>
   * The bool_or constraint forces at least one literal to be true.
   * </pre>
   *
   * <code>.operations_research.sat.BoolArgumentProto bool_or = 3;</code>
   */
  com.google.ortools.sat.BoolArgumentProtoOrBuilder getBoolOrOrBuilder();

  /**
   * <pre>
   * The bool_and constraint forces all of the literals to be true.
   * This is a "redundant" constraint in the sense that this can easily be
   * encoded with many bool_or. It is just more space efficient and handled
   * slightly differently internally.
   * </pre>
   *
   * <code>.operations_research.sat.BoolArgumentProto bool_and = 4;</code>
   * @return Whether the boolAnd field is set.
   */
  boolean hasBoolAnd();
  /**
   * <pre>
   * The bool_and constraint forces all of the literals to be true.
   * This is a "redundant" constraint in the sense that this can easily be
   * encoded with many bool_or. It is just more space efficient and handled
   * slightly differently internally.
   * </pre>
   *
   * <code>.operations_research.sat.BoolArgumentProto bool_and = 4;</code>
   * @return The boolAnd.
   */
  com.google.ortools.sat.BoolArgumentProto getBoolAnd();
  /**
   * <pre>
   * The bool_and constraint forces all of the literals to be true.
   * This is a "redundant" constraint in the sense that this can easily be
   * encoded with many bool_or. It is just more space efficient and handled
   * slightly differently internally.
   * </pre>
   *
   * <code>.operations_research.sat.BoolArgumentProto bool_and = 4;</code>
   */
  com.google.ortools.sat.BoolArgumentProtoOrBuilder getBoolAndOrBuilder();

  /**
   * <pre>
   * The at_most_one constraint enforces that no more than one literal is
   * true at the same time. Note that an at most one constraint of length n
   * could be encoded with n bool_and constraint with n-1 term on the right
   * hand side. So in a sense, this constraint contribute directly to the
   * "implication-graph" or the 2-SAT part of the model.
   * </pre>
   *
   * <code>.operations_research.sat.BoolArgumentProto at_most_one = 26;</code>
   * @return Whether the atMostOne field is set.
   */
  boolean hasAtMostOne();
  /**
   * <pre>
   * The at_most_one constraint enforces that no more than one literal is
   * true at the same time. Note that an at most one constraint of length n
   * could be encoded with n bool_and constraint with n-1 term on the right
   * hand side. So in a sense, this constraint contribute directly to the
   * "implication-graph" or the 2-SAT part of the model.
   * </pre>
   *
   * <code>.operations_research.sat.BoolArgumentProto at_most_one = 26;</code>
   * @return The atMostOne.
   */
  com.google.ortools.sat.BoolArgumentProto getAtMostOne();
  /**
   * <pre>
   * The at_most_one constraint enforces that no more than one literal is
   * true at the same time. Note that an at most one constraint of length n
   * could be encoded with n bool_and constraint with n-1 term on the right
   * hand side. So in a sense, this constraint contribute directly to the
   * "implication-graph" or the 2-SAT part of the model.
   * </pre>
   *
   * <code>.operations_research.sat.BoolArgumentProto at_most_one = 26;</code>
   */
  com.google.ortools.sat.BoolArgumentProtoOrBuilder getAtMostOneOrBuilder();

  /**
   * <pre>
   * The bool_xor constraint forces an odd number of the literals to be true.
   * </pre>
   *
   * <code>.operations_research.sat.BoolArgumentProto bool_xor = 5;</code>
   * @return Whether the boolXor field is set.
   */
  boolean hasBoolXor();
  /**
   * <pre>
   * The bool_xor constraint forces an odd number of the literals to be true.
   * </pre>
   *
   * <code>.operations_research.sat.BoolArgumentProto bool_xor = 5;</code>
   * @return The boolXor.
   */
  com.google.ortools.sat.BoolArgumentProto getBoolXor();
  /**
   * <pre>
   * The bool_xor constraint forces an odd number of the literals to be true.
   * </pre>
   *
   * <code>.operations_research.sat.BoolArgumentProto bool_xor = 5;</code>
   */
  com.google.ortools.sat.BoolArgumentProtoOrBuilder getBoolXorOrBuilder();

  /**
   * <pre>
   * The int_div constraint forces the target to equal vars[0] / vars[1].
   * </pre>
   *
   * <code>.operations_research.sat.IntegerArgumentProto int_div = 7;</code>
   * @return Whether the intDiv field is set.
   */
  boolean hasIntDiv();
  /**
   * <pre>
   * The int_div constraint forces the target to equal vars[0] / vars[1].
   * </pre>
   *
   * <code>.operations_research.sat.IntegerArgumentProto int_div = 7;</code>
   * @return The intDiv.
   */
  com.google.ortools.sat.IntegerArgumentProto getIntDiv();
  /**
   * <pre>
   * The int_div constraint forces the target to equal vars[0] / vars[1].
   * </pre>
   *
   * <code>.operations_research.sat.IntegerArgumentProto int_div = 7;</code>
   */
  com.google.ortools.sat.IntegerArgumentProtoOrBuilder getIntDivOrBuilder();

  /**
   * <pre>
   * The int_mod constraint forces the target to equal vars[0] % vars[1].
   * </pre>
   *
   * <code>.operations_research.sat.IntegerArgumentProto int_mod = 8;</code>
   * @return Whether the intMod field is set.
   */
  boolean hasIntMod();
  /**
   * <pre>
   * The int_mod constraint forces the target to equal vars[0] % vars[1].
   * </pre>
   *
   * <code>.operations_research.sat.IntegerArgumentProto int_mod = 8;</code>
   * @return The intMod.
   */
  com.google.ortools.sat.IntegerArgumentProto getIntMod();
  /**
   * <pre>
   * The int_mod constraint forces the target to equal vars[0] % vars[1].
   * </pre>
   *
   * <code>.operations_research.sat.IntegerArgumentProto int_mod = 8;</code>
   */
  com.google.ortools.sat.IntegerArgumentProtoOrBuilder getIntModOrBuilder();

  /**
   * <pre>
   * The int_max constraint forces the target to equal the maximum of all
   * variables.
   * TODO(user): Remove int_max in favor of lin_max.
   * </pre>
   *
   * <code>.operations_research.sat.IntegerArgumentProto int_max = 9;</code>
   * @return Whether the intMax field is set.
   */
  boolean hasIntMax();
  /**
   * <pre>
   * The int_max constraint forces the target to equal the maximum of all
   * variables.
   * TODO(user): Remove int_max in favor of lin_max.
   * </pre>
   *
   * <code>.operations_research.sat.IntegerArgumentProto int_max = 9;</code>
   * @return The intMax.
   */
  com.google.ortools.sat.IntegerArgumentProto getIntMax();
  /**
   * <pre>
   * The int_max constraint forces the target to equal the maximum of all
   * variables.
   * TODO(user): Remove int_max in favor of lin_max.
   * </pre>
   *
   * <code>.operations_research.sat.IntegerArgumentProto int_max = 9;</code>
   */
  com.google.ortools.sat.IntegerArgumentProtoOrBuilder getIntMaxOrBuilder();

  /**
   * <pre>
   * The lin_max constraint forces the target to equal the maximum of all
   * linear expressions.
   * </pre>
   *
   * <code>.operations_research.sat.LinearArgumentProto lin_max = 27;</code>
   * @return Whether the linMax field is set.
   */
  boolean hasLinMax();
  /**
   * <pre>
   * The lin_max constraint forces the target to equal the maximum of all
   * linear expressions.
   * </pre>
   *
   * <code>.operations_research.sat.LinearArgumentProto lin_max = 27;</code>
   * @return The linMax.
   */
  com.google.ortools.sat.LinearArgumentProto getLinMax();
  /**
   * <pre>
   * The lin_max constraint forces the target to equal the maximum of all
   * linear expressions.
   * </pre>
   *
   * <code>.operations_research.sat.LinearArgumentProto lin_max = 27;</code>
   */
  com.google.ortools.sat.LinearArgumentProtoOrBuilder getLinMaxOrBuilder();

  /**
   * <pre>
   * The int_min constraint forces the target to equal the minimum of all
   * variables.
   * TODO(user): Remove int_min in favor of lin_min.
   * </pre>
   *
   * <code>.operations_research.sat.IntegerArgumentProto int_min = 10;</code>
   * @return Whether the intMin field is set.
   */
  boolean hasIntMin();
  /**
   * <pre>
   * The int_min constraint forces the target to equal the minimum of all
   * variables.
   * TODO(user): Remove int_min in favor of lin_min.
   * </pre>
   *
   * <code>.operations_research.sat.IntegerArgumentProto int_min = 10;</code>
   * @return The intMin.
   */
  com.google.ortools.sat.IntegerArgumentProto getIntMin();
  /**
   * <pre>
   * The int_min constraint forces the target to equal the minimum of all
   * variables.
   * TODO(user): Remove int_min in favor of lin_min.
   * </pre>
   *
   * <code>.operations_research.sat.IntegerArgumentProto int_min = 10;</code>
   */
  com.google.ortools.sat.IntegerArgumentProtoOrBuilder getIntMinOrBuilder();

  /**
   * <pre>
   * The lin_min constraint forces the target to equal the minimum of all
   * linear expressions.
   * </pre>
   *
   * <code>.operations_research.sat.LinearArgumentProto lin_min = 28;</code>
   * @return Whether the linMin field is set.
   */
  boolean hasLinMin();
  /**
   * <pre>
   * The lin_min constraint forces the target to equal the minimum of all
   * linear expressions.
   * </pre>
   *
   * <code>.operations_research.sat.LinearArgumentProto lin_min = 28;</code>
   * @return The linMin.
   */
  com.google.ortools.sat.LinearArgumentProto getLinMin();
  /**
   * <pre>
   * The lin_min constraint forces the target to equal the minimum of all
   * linear expressions.
   * </pre>
   *
   * <code>.operations_research.sat.LinearArgumentProto lin_min = 28;</code>
   */
  com.google.ortools.sat.LinearArgumentProtoOrBuilder getLinMinOrBuilder();

  /**
   * <pre>
   * The int_prod constraint forces the target to equal the product of all
   * variables.
   * </pre>
   *
   * <code>.operations_research.sat.IntegerArgumentProto int_prod = 11;</code>
   * @return Whether the intProd field is set.
   */
  boolean hasIntProd();
  /**
   * <pre>
   * The int_prod constraint forces the target to equal the product of all
   * variables.
   * </pre>
   *
   * <code>.operations_research.sat.IntegerArgumentProto int_prod = 11;</code>
   * @return The intProd.
   */
  com.google.ortools.sat.IntegerArgumentProto getIntProd();
  /**
   * <pre>
   * The int_prod constraint forces the target to equal the product of all
   * variables.
   * </pre>
   *
   * <code>.operations_research.sat.IntegerArgumentProto int_prod = 11;</code>
   */
  com.google.ortools.sat.IntegerArgumentProtoOrBuilder getIntProdOrBuilder();

  /**
   * <pre>
   * The linear constraint enforces a linear inequality among the variables,
   * such as 0 &lt;= x + 2y &lt;= 10.
   * </pre>
   *
   * <code>.operations_research.sat.LinearConstraintProto linear = 12;</code>
   * @return Whether the linear field is set.
   */
  boolean hasLinear();
  /**
   * <pre>
   * The linear constraint enforces a linear inequality among the variables,
   * such as 0 &lt;= x + 2y &lt;= 10.
   * </pre>
   *
   * <code>.operations_research.sat.LinearConstraintProto linear = 12;</code>
   * @return The linear.
   */
  com.google.ortools.sat.LinearConstraintProto getLinear();
  /**
   * <pre>
   * The linear constraint enforces a linear inequality among the variables,
   * such as 0 &lt;= x + 2y &lt;= 10.
   * </pre>
   *
   * <code>.operations_research.sat.LinearConstraintProto linear = 12;</code>
   */
  com.google.ortools.sat.LinearConstraintProtoOrBuilder getLinearOrBuilder();

  /**
   * <pre>
   * The all_diff constraint forces all variables to take different values.
   * </pre>
   *
   * <code>.operations_research.sat.AllDifferentConstraintProto all_diff = 13;</code>
   * @return Whether the allDiff field is set.
   */
  boolean hasAllDiff();
  /**
   * <pre>
   * The all_diff constraint forces all variables to take different values.
   * </pre>
   *
   * <code>.operations_research.sat.AllDifferentConstraintProto all_diff = 13;</code>
   * @return The allDiff.
   */
  com.google.ortools.sat.AllDifferentConstraintProto getAllDiff();
  /**
   * <pre>
   * The all_diff constraint forces all variables to take different values.
   * </pre>
   *
   * <code>.operations_research.sat.AllDifferentConstraintProto all_diff = 13;</code>
   */
  com.google.ortools.sat.AllDifferentConstraintProtoOrBuilder getAllDiffOrBuilder();

  /**
   * <pre>
   * The element constraint forces the variable with the given index
   * to be equal to the target.
   * </pre>
   *
   * <code>.operations_research.sat.ElementConstraintProto element = 14;</code>
   * @return Whether the element field is set.
   */
  boolean hasElement();
  /**
   * <pre>
   * The element constraint forces the variable with the given index
   * to be equal to the target.
   * </pre>
   *
   * <code>.operations_research.sat.ElementConstraintProto element = 14;</code>
   * @return The element.
   */
  com.google.ortools.sat.ElementConstraintProto getElement();
  /**
   * <pre>
   * The element constraint forces the variable with the given index
   * to be equal to the target.
   * </pre>
   *
   * <code>.operations_research.sat.ElementConstraintProto element = 14;</code>
   */
  com.google.ortools.sat.ElementConstraintProtoOrBuilder getElementOrBuilder();

  /**
   * <pre>
   * The circuit constraint takes a graph and forces the arcs present
   * (with arc presence indicated by a literal) to form a unique cycle.
   * </pre>
   *
   * <code>.operations_research.sat.CircuitConstraintProto circuit = 15;</code>
   * @return Whether the circuit field is set.
   */
  boolean hasCircuit();
  /**
   * <pre>
   * The circuit constraint takes a graph and forces the arcs present
   * (with arc presence indicated by a literal) to form a unique cycle.
   * </pre>
   *
   * <code>.operations_research.sat.CircuitConstraintProto circuit = 15;</code>
   * @return The circuit.
   */
  com.google.ortools.sat.CircuitConstraintProto getCircuit();
  /**
   * <pre>
   * The circuit constraint takes a graph and forces the arcs present
   * (with arc presence indicated by a literal) to form a unique cycle.
   * </pre>
   *
   * <code>.operations_research.sat.CircuitConstraintProto circuit = 15;</code>
   */
  com.google.ortools.sat.CircuitConstraintProtoOrBuilder getCircuitOrBuilder();

  /**
   * <pre>
   * The routes constraint implements the vehicle routing problem.
   * </pre>
   *
   * <code>.operations_research.sat.RoutesConstraintProto routes = 23;</code>
   * @return Whether the routes field is set.
   */
  boolean hasRoutes();
  /**
   * <pre>
   * The routes constraint implements the vehicle routing problem.
   * </pre>
   *
   * <code>.operations_research.sat.RoutesConstraintProto routes = 23;</code>
   * @return The routes.
   */
  com.google.ortools.sat.RoutesConstraintProto getRoutes();
  /**
   * <pre>
   * The routes constraint implements the vehicle routing problem.
   * </pre>
   *
   * <code>.operations_research.sat.RoutesConstraintProto routes = 23;</code>
   */
  com.google.ortools.sat.RoutesConstraintProtoOrBuilder getRoutesOrBuilder();

  /**
   * <pre>
   * The circuit_covering constraint is similar to the circuit constraint,
   * but allows multiple non-overlapping cycles instead of just one.
   * </pre>
   *
   * <code>.operations_research.sat.CircuitCoveringConstraintProto circuit_covering = 25;</code>
   * @return Whether the circuitCovering field is set.
   */
  boolean hasCircuitCovering();
  /**
   * <pre>
   * The circuit_covering constraint is similar to the circuit constraint,
   * but allows multiple non-overlapping cycles instead of just one.
   * </pre>
   *
   * <code>.operations_research.sat.CircuitCoveringConstraintProto circuit_covering = 25;</code>
   * @return The circuitCovering.
   */
  com.google.ortools.sat.CircuitCoveringConstraintProto getCircuitCovering();
  /**
   * <pre>
   * The circuit_covering constraint is similar to the circuit constraint,
   * but allows multiple non-overlapping cycles instead of just one.
   * </pre>
   *
   * <code>.operations_research.sat.CircuitCoveringConstraintProto circuit_covering = 25;</code>
   */
  com.google.ortools.sat.CircuitCoveringConstraintProtoOrBuilder getCircuitCoveringOrBuilder();

  /**
   * <pre>
   * The table constraint enforces what values a tuple of variables may
   * take.
   * </pre>
   *
   * <code>.operations_research.sat.TableConstraintProto table = 16;</code>
   * @return Whether the table field is set.
   */
  boolean hasTable();
  /**
   * <pre>
   * The table constraint enforces what values a tuple of variables may
   * take.
   * </pre>
   *
   * <code>.operations_research.sat.TableConstraintProto table = 16;</code>
   * @return The table.
   */
  com.google.ortools.sat.TableConstraintProto getTable();
  /**
   * <pre>
   * The table constraint enforces what values a tuple of variables may
   * take.
   * </pre>
   *
   * <code>.operations_research.sat.TableConstraintProto table = 16;</code>
   */
  com.google.ortools.sat.TableConstraintProtoOrBuilder getTableOrBuilder();

  /**
   * <pre>
   * The automaton constraint forces a sequence of variables to be accepted
   * by an automaton.
   * </pre>
   *
   * <code>.operations_research.sat.AutomatonConstraintProto automaton = 17;</code>
   * @return Whether the automaton field is set.
   */
  boolean hasAutomaton();
  /**
   * <pre>
   * The automaton constraint forces a sequence of variables to be accepted
   * by an automaton.
   * </pre>
   *
   * <code>.operations_research.sat.AutomatonConstraintProto automaton = 17;</code>
   * @return The automaton.
   */
  com.google.ortools.sat.AutomatonConstraintProto getAutomaton();
  /**
   * <pre>
   * The automaton constraint forces a sequence of variables to be accepted
   * by an automaton.
   * </pre>
   *
   * <code>.operations_research.sat.AutomatonConstraintProto automaton = 17;</code>
   */
  com.google.ortools.sat.AutomatonConstraintProtoOrBuilder getAutomatonOrBuilder();

  /**
   * <pre>
   * The inverse constraint forces two arrays to be inverses of each other:
   * the values of one are the indices of the other, and vice versa.
   * </pre>
   *
   * <code>.operations_research.sat.InverseConstraintProto inverse = 18;</code>
   * @return Whether the inverse field is set.
   */
  boolean hasInverse();
  /**
   * <pre>
   * The inverse constraint forces two arrays to be inverses of each other:
   * the values of one are the indices of the other, and vice versa.
   * </pre>
   *
   * <code>.operations_research.sat.InverseConstraintProto inverse = 18;</code>
   * @return The inverse.
   */
  com.google.ortools.sat.InverseConstraintProto getInverse();
  /**
   * <pre>
   * The inverse constraint forces two arrays to be inverses of each other:
   * the values of one are the indices of the other, and vice versa.
   * </pre>
   *
   * <code>.operations_research.sat.InverseConstraintProto inverse = 18;</code>
   */
  com.google.ortools.sat.InverseConstraintProtoOrBuilder getInverseOrBuilder();

  /**
   * <pre>
   * The reservoir constraint forces the sum of a set of active demands
   * to always be between a specified minimum and maximum value during
   * specific times.
   * </pre>
   *
   * <code>.operations_research.sat.ReservoirConstraintProto reservoir = 24;</code>
   * @return Whether the reservoir field is set.
   */
  boolean hasReservoir();
  /**
   * <pre>
   * The reservoir constraint forces the sum of a set of active demands
   * to always be between a specified minimum and maximum value during
   * specific times.
   * </pre>
   *
   * <code>.operations_research.sat.ReservoirConstraintProto reservoir = 24;</code>
   * @return The reservoir.
   */
  com.google.ortools.sat.ReservoirConstraintProto getReservoir();
  /**
   * <pre>
   * The reservoir constraint forces the sum of a set of active demands
   * to always be between a specified minimum and maximum value during
   * specific times.
   * </pre>
   *
   * <code>.operations_research.sat.ReservoirConstraintProto reservoir = 24;</code>
   */
  com.google.ortools.sat.ReservoirConstraintProtoOrBuilder getReservoirOrBuilder();

  /**
   * <pre>
   * The interval constraint takes a start, end, and size, and forces
   * start + size == end.
   * </pre>
   *
   * <code>.operations_research.sat.IntervalConstraintProto interval = 19;</code>
   * @return Whether the interval field is set.
   */
  boolean hasInterval();
  /**
   * <pre>
   * The interval constraint takes a start, end, and size, and forces
   * start + size == end.
   * </pre>
   *
   * <code>.operations_research.sat.IntervalConstraintProto interval = 19;</code>
   * @return The interval.
   */
  com.google.ortools.sat.IntervalConstraintProto getInterval();
  /**
   * <pre>
   * The interval constraint takes a start, end, and size, and forces
   * start + size == end.
   * </pre>
   *
   * <code>.operations_research.sat.IntervalConstraintProto interval = 19;</code>
   */
  com.google.ortools.sat.IntervalConstraintProtoOrBuilder getIntervalOrBuilder();

  /**
   * <pre>
   * The no_overlap constraint prevents a set of intervals from
   * overlapping; in scheduling, this is called a disjunctive
   * constraint.
   * </pre>
   *
   * <code>.operations_research.sat.NoOverlapConstraintProto no_overlap = 20;</code>
   * @return Whether the noOverlap field is set.
   */
  boolean hasNoOverlap();
  /**
   * <pre>
   * The no_overlap constraint prevents a set of intervals from
   * overlapping; in scheduling, this is called a disjunctive
   * constraint.
   * </pre>
   *
   * <code>.operations_research.sat.NoOverlapConstraintProto no_overlap = 20;</code>
   * @return The noOverlap.
   */
  com.google.ortools.sat.NoOverlapConstraintProto getNoOverlap();
  /**
   * <pre>
   * The no_overlap constraint prevents a set of intervals from
   * overlapping; in scheduling, this is called a disjunctive
   * constraint.
   * </pre>
   *
   * <code>.operations_research.sat.NoOverlapConstraintProto no_overlap = 20;</code>
   */
  com.google.ortools.sat.NoOverlapConstraintProtoOrBuilder getNoOverlapOrBuilder();

  /**
   * <pre>
   * The no_overlap_2d constraint prevents a set of boxes from overlapping.
   * </pre>
   *
   * <code>.operations_research.sat.NoOverlap2DConstraintProto no_overlap_2d = 21;</code>
   * @return Whether the noOverlap2d field is set.
   */
  boolean hasNoOverlap2D();
  /**
   * <pre>
   * The no_overlap_2d constraint prevents a set of boxes from overlapping.
   * </pre>
   *
   * <code>.operations_research.sat.NoOverlap2DConstraintProto no_overlap_2d = 21;</code>
   * @return The noOverlap2d.
   */
  com.google.ortools.sat.NoOverlap2DConstraintProto getNoOverlap2D();
  /**
   * <pre>
   * The no_overlap_2d constraint prevents a set of boxes from overlapping.
   * </pre>
   *
   * <code>.operations_research.sat.NoOverlap2DConstraintProto no_overlap_2d = 21;</code>
   */
  com.google.ortools.sat.NoOverlap2DConstraintProtoOrBuilder getNoOverlap2DOrBuilder();

  /**
   * <pre>
   * The cumulative constraint ensures that for any integer point, the sum
   * of the demands of the intervals containing that point does not exceed
   * the capacity.
   * </pre>
   *
   * <code>.operations_research.sat.CumulativeConstraintProto cumulative = 22;</code>
   * @return Whether the cumulative field is set.
   */
  boolean hasCumulative();
  /**
   * <pre>
   * The cumulative constraint ensures that for any integer point, the sum
   * of the demands of the intervals containing that point does not exceed
   * the capacity.
   * </pre>
   *
   * <code>.operations_research.sat.CumulativeConstraintProto cumulative = 22;</code>
   * @return The cumulative.
   */
  com.google.ortools.sat.CumulativeConstraintProto getCumulative();
  /**
   * <pre>
   * The cumulative constraint ensures that for any integer point, the sum
   * of the demands of the intervals containing that point does not exceed
   * the capacity.
   * </pre>
   *
   * <code>.operations_research.sat.CumulativeConstraintProto cumulative = 22;</code>
   */
  com.google.ortools.sat.CumulativeConstraintProtoOrBuilder getCumulativeOrBuilder();

  public com.google.ortools.sat.ConstraintProto.ConstraintCase getConstraintCase();
}

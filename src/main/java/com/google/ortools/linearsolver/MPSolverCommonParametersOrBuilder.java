// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ortools/linear_solver/linear_solver.proto

package com.google.ortools.linearsolver;

public interface MPSolverCommonParametersOrBuilder extends
    // @@protoc_insertion_point(interface_extends:operations_research.MPSolverCommonParameters)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * The solver stops if the relative MIP gap reaches this value or below.
   * The relative MIP gap is an upper bound of the relative distance to the
   * optimum, and it is defined as:
   *   abs(best_bound - incumbent) / abs(incumbent) [Gurobi]
   *   abs(best_bound - incumbent) / min(abs(best_bound), abs(incumbent)) [SCIP]
   * where "incumbent" is the objective value of the best solution found so far
   * (i.e., lowest when minimizing, highest when maximizing), and "best_bound"
   * is the tightest bound of the objective determined so far (i.e., highest
   * when minimizing, and lowest when maximizing). The MIP Gap is sensitive to
   * objective offset. If the denominator is 0 the MIP Gap is INFINITY for SCIP
   * and Gurobi. Of note, "incumbent" and "best bound" are called "primal bound"
   * and "dual bound" in SCIP, respectively.
   * Ask or-core-team&#64; for other solvers.
   * </pre>
   *
   * <code>optional .operations_research.OptionalDouble relative_mip_gap = 1;</code>
   * @return Whether the relativeMipGap field is set.
   */
  boolean hasRelativeMipGap();
  /**
   * <pre>
   * The solver stops if the relative MIP gap reaches this value or below.
   * The relative MIP gap is an upper bound of the relative distance to the
   * optimum, and it is defined as:
   *   abs(best_bound - incumbent) / abs(incumbent) [Gurobi]
   *   abs(best_bound - incumbent) / min(abs(best_bound), abs(incumbent)) [SCIP]
   * where "incumbent" is the objective value of the best solution found so far
   * (i.e., lowest when minimizing, highest when maximizing), and "best_bound"
   * is the tightest bound of the objective determined so far (i.e., highest
   * when minimizing, and lowest when maximizing). The MIP Gap is sensitive to
   * objective offset. If the denominator is 0 the MIP Gap is INFINITY for SCIP
   * and Gurobi. Of note, "incumbent" and "best bound" are called "primal bound"
   * and "dual bound" in SCIP, respectively.
   * Ask or-core-team&#64; for other solvers.
   * </pre>
   *
   * <code>optional .operations_research.OptionalDouble relative_mip_gap = 1;</code>
   * @return The relativeMipGap.
   */
  com.google.ortools.linearsolver.OptionalDouble getRelativeMipGap();
  /**
   * <pre>
   * The solver stops if the relative MIP gap reaches this value or below.
   * The relative MIP gap is an upper bound of the relative distance to the
   * optimum, and it is defined as:
   *   abs(best_bound - incumbent) / abs(incumbent) [Gurobi]
   *   abs(best_bound - incumbent) / min(abs(best_bound), abs(incumbent)) [SCIP]
   * where "incumbent" is the objective value of the best solution found so far
   * (i.e., lowest when minimizing, highest when maximizing), and "best_bound"
   * is the tightest bound of the objective determined so far (i.e., highest
   * when minimizing, and lowest when maximizing). The MIP Gap is sensitive to
   * objective offset. If the denominator is 0 the MIP Gap is INFINITY for SCIP
   * and Gurobi. Of note, "incumbent" and "best bound" are called "primal bound"
   * and "dual bound" in SCIP, respectively.
   * Ask or-core-team&#64; for other solvers.
   * </pre>
   *
   * <code>optional .operations_research.OptionalDouble relative_mip_gap = 1;</code>
   */
  com.google.ortools.linearsolver.OptionalDoubleOrBuilder getRelativeMipGapOrBuilder();

  /**
   * <pre>
   * Tolerance for primal feasibility of basic solutions: this is the maximum
   * allowed error in constraint satisfiability.
   * For SCIP this includes integrality constraints. For Gurobi it does not, you
   * need to set the custom parameter IntFeasTol.
   * </pre>
   *
   * <code>optional .operations_research.OptionalDouble primal_tolerance = 2;</code>
   * @return Whether the primalTolerance field is set.
   */
  boolean hasPrimalTolerance();
  /**
   * <pre>
   * Tolerance for primal feasibility of basic solutions: this is the maximum
   * allowed error in constraint satisfiability.
   * For SCIP this includes integrality constraints. For Gurobi it does not, you
   * need to set the custom parameter IntFeasTol.
   * </pre>
   *
   * <code>optional .operations_research.OptionalDouble primal_tolerance = 2;</code>
   * @return The primalTolerance.
   */
  com.google.ortools.linearsolver.OptionalDouble getPrimalTolerance();
  /**
   * <pre>
   * Tolerance for primal feasibility of basic solutions: this is the maximum
   * allowed error in constraint satisfiability.
   * For SCIP this includes integrality constraints. For Gurobi it does not, you
   * need to set the custom parameter IntFeasTol.
   * </pre>
   *
   * <code>optional .operations_research.OptionalDouble primal_tolerance = 2;</code>
   */
  com.google.ortools.linearsolver.OptionalDoubleOrBuilder getPrimalToleranceOrBuilder();

  /**
   * <pre>
   * Tolerance for dual feasibility.
   * For SCIP and Gurobi this is the feasibility tolerance for reduced costs in
   * LP solution: reduced costs must all be smaller than this value in the
   * improving direction in order for a model to be declared optimal.
   * Not supported for other solvers.
   * </pre>
   *
   * <code>optional .operations_research.OptionalDouble dual_tolerance = 3;</code>
   * @return Whether the dualTolerance field is set.
   */
  boolean hasDualTolerance();
  /**
   * <pre>
   * Tolerance for dual feasibility.
   * For SCIP and Gurobi this is the feasibility tolerance for reduced costs in
   * LP solution: reduced costs must all be smaller than this value in the
   * improving direction in order for a model to be declared optimal.
   * Not supported for other solvers.
   * </pre>
   *
   * <code>optional .operations_research.OptionalDouble dual_tolerance = 3;</code>
   * @return The dualTolerance.
   */
  com.google.ortools.linearsolver.OptionalDouble getDualTolerance();
  /**
   * <pre>
   * Tolerance for dual feasibility.
   * For SCIP and Gurobi this is the feasibility tolerance for reduced costs in
   * LP solution: reduced costs must all be smaller than this value in the
   * improving direction in order for a model to be declared optimal.
   * Not supported for other solvers.
   * </pre>
   *
   * <code>optional .operations_research.OptionalDouble dual_tolerance = 3;</code>
   */
  com.google.ortools.linearsolver.OptionalDoubleOrBuilder getDualToleranceOrBuilder();

  /**
   * <pre>
   * Algorithm to solve linear programs.
   * Ask or-core-team&#64; if you want to know what this does exactly.
   * </pre>
   *
   * <code>optional .operations_research.MPSolverCommonParameters.LPAlgorithmValues lp_algorithm = 4 [default = LP_ALGO_UNSPECIFIED];</code>
   * @return Whether the lpAlgorithm field is set.
   */
  boolean hasLpAlgorithm();
  /**
   * <pre>
   * Algorithm to solve linear programs.
   * Ask or-core-team&#64; if you want to know what this does exactly.
   * </pre>
   *
   * <code>optional .operations_research.MPSolverCommonParameters.LPAlgorithmValues lp_algorithm = 4 [default = LP_ALGO_UNSPECIFIED];</code>
   * @return The lpAlgorithm.
   */
  com.google.ortools.linearsolver.MPSolverCommonParameters.LPAlgorithmValues getLpAlgorithm();

  /**
   * <pre>
   * Gurobi and SCIP enable presolve by default.
   * Ask or-core-team&#64; for other solvers.
   * </pre>
   *
   * <code>optional .operations_research.OptionalBoolean presolve = 5 [default = BOOL_UNSPECIFIED];</code>
   * @return Whether the presolve field is set.
   */
  boolean hasPresolve();
  /**
   * <pre>
   * Gurobi and SCIP enable presolve by default.
   * Ask or-core-team&#64; for other solvers.
   * </pre>
   *
   * <code>optional .operations_research.OptionalBoolean presolve = 5 [default = BOOL_UNSPECIFIED];</code>
   * @return The presolve.
   */
  com.google.ortools.util.OptionalBoolean getPresolve();

  /**
   * <pre>
   * Enable automatic scaling of matrix coefficients and objective. Available
   * for Gurobi and GLOP.
   * Ask or-core-team&#64; if you want more details.
   * </pre>
   *
   * <code>optional .operations_research.OptionalBoolean scaling = 7 [default = BOOL_UNSPECIFIED];</code>
   * @return Whether the scaling field is set.
   */
  boolean hasScaling();
  /**
   * <pre>
   * Enable automatic scaling of matrix coefficients and objective. Available
   * for Gurobi and GLOP.
   * Ask or-core-team&#64; if you want more details.
   * </pre>
   *
   * <code>optional .operations_research.OptionalBoolean scaling = 7 [default = BOOL_UNSPECIFIED];</code>
   * @return The scaling.
   */
  com.google.ortools.util.OptionalBoolean getScaling();
}

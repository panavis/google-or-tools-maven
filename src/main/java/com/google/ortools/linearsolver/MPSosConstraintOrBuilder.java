// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ortools/linear_solver/linear_solver.proto

package com.google.ortools.linearsolver;

public interface MPSosConstraintOrBuilder extends
    // @@protoc_insertion_point(interface_extends:operations_research.MPSosConstraint)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <code>optional .operations_research.MPSosConstraint.Type type = 1 [default = SOS1_DEFAULT];</code>
   * @return Whether the type field is set.
   */
  boolean hasType();
  /**
   * <code>optional .operations_research.MPSosConstraint.Type type = 1 [default = SOS1_DEFAULT];</code>
   * @return The type.
   */
  com.google.ortools.linearsolver.MPSosConstraint.Type getType();

  /**
   * <pre>
   * Variable index (w.r.t. the "variable" field of MPModelProto) of the
   * variables in the SOS.
   * </pre>
   *
   * <code>repeated int32 var_index = 2;</code>
   * @return A list containing the varIndex.
   */
  java.util.List<java.lang.Integer> getVarIndexList();
  /**
   * <pre>
   * Variable index (w.r.t. the "variable" field of MPModelProto) of the
   * variables in the SOS.
   * </pre>
   *
   * <code>repeated int32 var_index = 2;</code>
   * @return The count of varIndex.
   */
  int getVarIndexCount();
  /**
   * <pre>
   * Variable index (w.r.t. the "variable" field of MPModelProto) of the
   * variables in the SOS.
   * </pre>
   *
   * <code>repeated int32 var_index = 2;</code>
   * @param index The index of the element to return.
   * @return The varIndex at the given index.
   */
  int getVarIndex(int index);

  /**
   * <pre>
   * Optional: SOS weights. If non-empty, must be of the same size as
   * "var_index", and strictly increasing. If empty and required by the
   * underlying solver, the 1..n sequence will be given as weights.
   * SUBTLE: The weights can help the solver make branch-and-bound decisions
   * that fit the underlying optimization model: after each LP relaxation, it
   * will compute the "average weight" of the SOS variables, weighted by value
   * (this is confusing: here we're using the values as weights), and the binary
   * branch decision will be: is the non-zero variable above or below that?
   * (weights are strictly monotonous, so the "cutoff" average weight
   * corresponds to a "cutoff" index in the var_index sequence).
   * </pre>
   *
   * <code>repeated double weight = 3;</code>
   * @return A list containing the weight.
   */
  java.util.List<java.lang.Double> getWeightList();
  /**
   * <pre>
   * Optional: SOS weights. If non-empty, must be of the same size as
   * "var_index", and strictly increasing. If empty and required by the
   * underlying solver, the 1..n sequence will be given as weights.
   * SUBTLE: The weights can help the solver make branch-and-bound decisions
   * that fit the underlying optimization model: after each LP relaxation, it
   * will compute the "average weight" of the SOS variables, weighted by value
   * (this is confusing: here we're using the values as weights), and the binary
   * branch decision will be: is the non-zero variable above or below that?
   * (weights are strictly monotonous, so the "cutoff" average weight
   * corresponds to a "cutoff" index in the var_index sequence).
   * </pre>
   *
   * <code>repeated double weight = 3;</code>
   * @return The count of weight.
   */
  int getWeightCount();
  /**
   * <pre>
   * Optional: SOS weights. If non-empty, must be of the same size as
   * "var_index", and strictly increasing. If empty and required by the
   * underlying solver, the 1..n sequence will be given as weights.
   * SUBTLE: The weights can help the solver make branch-and-bound decisions
   * that fit the underlying optimization model: after each LP relaxation, it
   * will compute the "average weight" of the SOS variables, weighted by value
   * (this is confusing: here we're using the values as weights), and the binary
   * branch decision will be: is the non-zero variable above or below that?
   * (weights are strictly monotonous, so the "cutoff" average weight
   * corresponds to a "cutoff" index in the var_index sequence).
   * </pre>
   *
   * <code>repeated double weight = 3;</code>
   * @param index The index of the element to return.
   * @return The weight at the given index.
   */
  double getWeight(int index);
}

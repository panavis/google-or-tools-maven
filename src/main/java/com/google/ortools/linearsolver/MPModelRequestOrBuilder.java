// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ortools/linear_solver/linear_solver.proto

package com.google.ortools.linearsolver;

public interface MPModelRequestOrBuilder extends
    // @@protoc_insertion_point(interface_extends:operations_research.MPModelRequest)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * The model to be optimized by the server.
   * </pre>
   *
   * <code>optional .operations_research.MPModelProto model = 1;</code>
   * @return Whether the model field is set.
   */
  boolean hasModel();
  /**
   * <pre>
   * The model to be optimized by the server.
   * </pre>
   *
   * <code>optional .operations_research.MPModelProto model = 1;</code>
   * @return The model.
   */
  com.google.ortools.linearsolver.MPModelProto getModel();
  /**
   * <pre>
   * The model to be optimized by the server.
   * </pre>
   *
   * <code>optional .operations_research.MPModelProto model = 1;</code>
   */
  com.google.ortools.linearsolver.MPModelProtoOrBuilder getModelOrBuilder();

  /**
   * <code>optional .operations_research.MPModelRequest.SolverType solver_type = 2;</code>
   * @return Whether the solverType field is set.
   */
  boolean hasSolverType();
  /**
   * <code>optional .operations_research.MPModelRequest.SolverType solver_type = 2;</code>
   * @return The solverType.
   */
  com.google.ortools.linearsolver.MPModelRequest.SolverType getSolverType();

  /**
   * <pre>
   * Maximum time to be spent by the solver to solve 'model'. If the server is
   * busy and the RPC's deadline_left is less than this, it will immediately
   * give up and return an error, without even trying to solve.
   * The client can use this to have a guarantee on how much time the
   * solver will spend on the problem (unless it finds and proves
   * an optimal solution more quickly).
   * If not specified, the time limit on the solver is the RPC's deadline_left.
   * </pre>
   *
   * <code>optional double solver_time_limit_seconds = 3;</code>
   * @return Whether the solverTimeLimitSeconds field is set.
   */
  boolean hasSolverTimeLimitSeconds();
  /**
   * <pre>
   * Maximum time to be spent by the solver to solve 'model'. If the server is
   * busy and the RPC's deadline_left is less than this, it will immediately
   * give up and return an error, without even trying to solve.
   * The client can use this to have a guarantee on how much time the
   * solver will spend on the problem (unless it finds and proves
   * an optimal solution more quickly).
   * If not specified, the time limit on the solver is the RPC's deadline_left.
   * </pre>
   *
   * <code>optional double solver_time_limit_seconds = 3;</code>
   * @return The solverTimeLimitSeconds.
   */
  double getSolverTimeLimitSeconds();

  /**
   * <pre>
   * If this is set, then EnableOutput() will be set on the internal MPSolver
   * that solves the model.
   * WARNING: if you set this on a request to prod servers, it will be rejected
   * and yield the RPC Application Error code MPSOLVER_SOLVER_TYPE_UNAVAILABLE.
   * </pre>
   *
   * <code>optional bool enable_internal_solver_output = 4 [default = false];</code>
   * @return Whether the enableInternalSolverOutput field is set.
   */
  boolean hasEnableInternalSolverOutput();
  /**
   * <pre>
   * If this is set, then EnableOutput() will be set on the internal MPSolver
   * that solves the model.
   * WARNING: if you set this on a request to prod servers, it will be rejected
   * and yield the RPC Application Error code MPSOLVER_SOLVER_TYPE_UNAVAILABLE.
   * </pre>
   *
   * <code>optional bool enable_internal_solver_output = 4 [default = false];</code>
   * @return The enableInternalSolverOutput.
   */
  boolean getEnableInternalSolverOutput();

  /**
   * <pre>
   * Advanced usage. Solver-specific parameters in the solver's own format,
   * different for each solver. For example, if you use SCIP and you want to
   * stop the solve earlier than the time limit if it reached a solution that is
   * at most 1% away from the optimal, you can set this to "limits/gap=0.01".
   * Note however that there is no "security" mechanism in place so it is up to
   * the client to make sure that the given options don't make the solve
   * non thread safe or use up too much memory for instance.
   * If the option format is not understood by the solver, the request will be
   * rejected and yield an RPC Application error with code
   * MPSOLVER_MODEL_INVALID_SOLVER_PARAMETERS.
   * </pre>
   *
   * <code>optional string solver_specific_parameters = 5;</code>
   * @return Whether the solverSpecificParameters field is set.
   */
  boolean hasSolverSpecificParameters();
  /**
   * <pre>
   * Advanced usage. Solver-specific parameters in the solver's own format,
   * different for each solver. For example, if you use SCIP and you want to
   * stop the solve earlier than the time limit if it reached a solution that is
   * at most 1% away from the optimal, you can set this to "limits/gap=0.01".
   * Note however that there is no "security" mechanism in place so it is up to
   * the client to make sure that the given options don't make the solve
   * non thread safe or use up too much memory for instance.
   * If the option format is not understood by the solver, the request will be
   * rejected and yield an RPC Application error with code
   * MPSOLVER_MODEL_INVALID_SOLVER_PARAMETERS.
   * </pre>
   *
   * <code>optional string solver_specific_parameters = 5;</code>
   * @return The solverSpecificParameters.
   */
  java.lang.String getSolverSpecificParameters();
  /**
   * <pre>
   * Advanced usage. Solver-specific parameters in the solver's own format,
   * different for each solver. For example, if you use SCIP and you want to
   * stop the solve earlier than the time limit if it reached a solution that is
   * at most 1% away from the optimal, you can set this to "limits/gap=0.01".
   * Note however that there is no "security" mechanism in place so it is up to
   * the client to make sure that the given options don't make the solve
   * non thread safe or use up too much memory for instance.
   * If the option format is not understood by the solver, the request will be
   * rejected and yield an RPC Application error with code
   * MPSOLVER_MODEL_INVALID_SOLVER_PARAMETERS.
   * </pre>
   *
   * <code>optional string solver_specific_parameters = 5;</code>
   * @return The bytes for solverSpecificParameters.
   */
  com.google.protobuf.ByteString
      getSolverSpecificParametersBytes();

  /**
   * <pre>
   * Advanced usage: model "delta". If used, "model" must be unset. See the
   * definition of MPModelDeltaProto.
   * </pre>
   *
   * <code>optional .operations_research.MPModelDeltaProto model_delta = 8;</code>
   * @return Whether the modelDelta field is set.
   */
  boolean hasModelDelta();
  /**
   * <pre>
   * Advanced usage: model "delta". If used, "model" must be unset. See the
   * definition of MPModelDeltaProto.
   * </pre>
   *
   * <code>optional .operations_research.MPModelDeltaProto model_delta = 8;</code>
   * @return The modelDelta.
   */
  com.google.ortools.linearsolver.MPModelDeltaProto getModelDelta();
  /**
   * <pre>
   * Advanced usage: model "delta". If used, "model" must be unset. See the
   * definition of MPModelDeltaProto.
   * </pre>
   *
   * <code>optional .operations_research.MPModelDeltaProto model_delta = 8;</code>
   */
  com.google.ortools.linearsolver.MPModelDeltaProtoOrBuilder getModelDeltaOrBuilder();
}

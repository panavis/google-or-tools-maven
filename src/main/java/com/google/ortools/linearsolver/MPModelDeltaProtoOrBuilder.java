// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ortools/linear_solver/linear_solver.proto

package com.google.ortools.linearsolver;

public interface MPModelDeltaProtoOrBuilder extends
    // @@protoc_insertion_point(interface_extends:operations_research.MPModelDeltaProto)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <code>optional string baseline_model_file_path = 1;</code>
   * @return Whether the baselineModelFilePath field is set.
   */
  boolean hasBaselineModelFilePath();
  /**
   * <code>optional string baseline_model_file_path = 1;</code>
   * @return The baselineModelFilePath.
   */
  java.lang.String getBaselineModelFilePath();
  /**
   * <code>optional string baseline_model_file_path = 1;</code>
   * @return The bytes for baselineModelFilePath.
   */
  com.google.protobuf.ByteString
      getBaselineModelFilePathBytes();

  /**
   * <pre>
   * The variable protos listed here will override (via MergeFrom()) the ones
   * in the baseline model: you only need to specify the fields that change.
   * To add a new variable, add it with a new variable index (variable indices
   * still need to span a dense integer interval).
   * You can't "delete" a variable but you can "neutralize" it by fixing its
   * value, setting its objective coefficient to zero, and by nullifying all
   * the terms involving it in the constraints.
   * </pre>
   *
   * <code>map&lt;int32, .operations_research.MPVariableProto&gt; variable_overrides = 2;</code>
   */
  int getVariableOverridesCount();
  /**
   * <pre>
   * The variable protos listed here will override (via MergeFrom()) the ones
   * in the baseline model: you only need to specify the fields that change.
   * To add a new variable, add it with a new variable index (variable indices
   * still need to span a dense integer interval).
   * You can't "delete" a variable but you can "neutralize" it by fixing its
   * value, setting its objective coefficient to zero, and by nullifying all
   * the terms involving it in the constraints.
   * </pre>
   *
   * <code>map&lt;int32, .operations_research.MPVariableProto&gt; variable_overrides = 2;</code>
   */
  boolean containsVariableOverrides(
      int key);
  /**
   * Use {@link #getVariableOverridesMap()} instead.
   */
  @java.lang.Deprecated
  java.util.Map<java.lang.Integer, com.google.ortools.linearsolver.MPVariableProto>
  getVariableOverrides();
  /**
   * <pre>
   * The variable protos listed here will override (via MergeFrom()) the ones
   * in the baseline model: you only need to specify the fields that change.
   * To add a new variable, add it with a new variable index (variable indices
   * still need to span a dense integer interval).
   * You can't "delete" a variable but you can "neutralize" it by fixing its
   * value, setting its objective coefficient to zero, and by nullifying all
   * the terms involving it in the constraints.
   * </pre>
   *
   * <code>map&lt;int32, .operations_research.MPVariableProto&gt; variable_overrides = 2;</code>
   */
  java.util.Map<java.lang.Integer, com.google.ortools.linearsolver.MPVariableProto>
  getVariableOverridesMap();
  /**
   * <pre>
   * The variable protos listed here will override (via MergeFrom()) the ones
   * in the baseline model: you only need to specify the fields that change.
   * To add a new variable, add it with a new variable index (variable indices
   * still need to span a dense integer interval).
   * You can't "delete" a variable but you can "neutralize" it by fixing its
   * value, setting its objective coefficient to zero, and by nullifying all
   * the terms involving it in the constraints.
   * </pre>
   *
   * <code>map&lt;int32, .operations_research.MPVariableProto&gt; variable_overrides = 2;</code>
   */

  com.google.ortools.linearsolver.MPVariableProto getVariableOverridesOrDefault(
      int key,
      com.google.ortools.linearsolver.MPVariableProto defaultValue);
  /**
   * <pre>
   * The variable protos listed here will override (via MergeFrom()) the ones
   * in the baseline model: you only need to specify the fields that change.
   * To add a new variable, add it with a new variable index (variable indices
   * still need to span a dense integer interval).
   * You can't "delete" a variable but you can "neutralize" it by fixing its
   * value, setting its objective coefficient to zero, and by nullifying all
   * the terms involving it in the constraints.
   * </pre>
   *
   * <code>map&lt;int32, .operations_research.MPVariableProto&gt; variable_overrides = 2;</code>
   */

  com.google.ortools.linearsolver.MPVariableProto getVariableOverridesOrThrow(
      int key);

  /**
   * <pre>
   * Constraints can be changed (or added) in the same way as variables, see
   * above. It's mostly like applying MergeFrom(), except that:
   * - the "var_index" and "coefficient" fields will be overridden like a map:
   *   if a key pre-exists, we overwrite its value, otherwise we add it.
   * - if you set the lower bound to -inf and the upper bound to +inf, thus
   *   effectively neutralizing the constraint, the solver will implicitly
   *   remove all of the constraint's terms.
   * </pre>
   *
   * <code>map&lt;int32, .operations_research.MPConstraintProto&gt; constraint_overrides = 3;</code>
   */
  int getConstraintOverridesCount();
  /**
   * <pre>
   * Constraints can be changed (or added) in the same way as variables, see
   * above. It's mostly like applying MergeFrom(), except that:
   * - the "var_index" and "coefficient" fields will be overridden like a map:
   *   if a key pre-exists, we overwrite its value, otherwise we add it.
   * - if you set the lower bound to -inf and the upper bound to +inf, thus
   *   effectively neutralizing the constraint, the solver will implicitly
   *   remove all of the constraint's terms.
   * </pre>
   *
   * <code>map&lt;int32, .operations_research.MPConstraintProto&gt; constraint_overrides = 3;</code>
   */
  boolean containsConstraintOverrides(
      int key);
  /**
   * Use {@link #getConstraintOverridesMap()} instead.
   */
  @java.lang.Deprecated
  java.util.Map<java.lang.Integer, com.google.ortools.linearsolver.MPConstraintProto>
  getConstraintOverrides();
  /**
   * <pre>
   * Constraints can be changed (or added) in the same way as variables, see
   * above. It's mostly like applying MergeFrom(), except that:
   * - the "var_index" and "coefficient" fields will be overridden like a map:
   *   if a key pre-exists, we overwrite its value, otherwise we add it.
   * - if you set the lower bound to -inf and the upper bound to +inf, thus
   *   effectively neutralizing the constraint, the solver will implicitly
   *   remove all of the constraint's terms.
   * </pre>
   *
   * <code>map&lt;int32, .operations_research.MPConstraintProto&gt; constraint_overrides = 3;</code>
   */
  java.util.Map<java.lang.Integer, com.google.ortools.linearsolver.MPConstraintProto>
  getConstraintOverridesMap();
  /**
   * <pre>
   * Constraints can be changed (or added) in the same way as variables, see
   * above. It's mostly like applying MergeFrom(), except that:
   * - the "var_index" and "coefficient" fields will be overridden like a map:
   *   if a key pre-exists, we overwrite its value, otherwise we add it.
   * - if you set the lower bound to -inf and the upper bound to +inf, thus
   *   effectively neutralizing the constraint, the solver will implicitly
   *   remove all of the constraint's terms.
   * </pre>
   *
   * <code>map&lt;int32, .operations_research.MPConstraintProto&gt; constraint_overrides = 3;</code>
   */

  com.google.ortools.linearsolver.MPConstraintProto getConstraintOverridesOrDefault(
      int key,
      com.google.ortools.linearsolver.MPConstraintProto defaultValue);
  /**
   * <pre>
   * Constraints can be changed (or added) in the same way as variables, see
   * above. It's mostly like applying MergeFrom(), except that:
   * - the "var_index" and "coefficient" fields will be overridden like a map:
   *   if a key pre-exists, we overwrite its value, otherwise we add it.
   * - if you set the lower bound to -inf and the upper bound to +inf, thus
   *   effectively neutralizing the constraint, the solver will implicitly
   *   remove all of the constraint's terms.
   * </pre>
   *
   * <code>map&lt;int32, .operations_research.MPConstraintProto&gt; constraint_overrides = 3;</code>
   */

  com.google.ortools.linearsolver.MPConstraintProto getConstraintOverridesOrThrow(
      int key);
}
